// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/weaveworks-liquidmetal/controller-pkg/client"
	"github.com/weaveworks-liquidmetal/flintlock/api/services/microvm/v1alpha1"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/types/known/emptypb"
)

type FakeClient struct {
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	CreateMicroVMStub        func(context.Context, *v1alpha1.CreateMicroVMRequest, ...grpc.CallOption) (*v1alpha1.CreateMicroVMResponse, error)
	createMicroVMMutex       sync.RWMutex
	createMicroVMArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.CreateMicroVMRequest
		arg3 []grpc.CallOption
	}
	createMicroVMReturns struct {
		result1 *v1alpha1.CreateMicroVMResponse
		result2 error
	}
	createMicroVMReturnsOnCall map[int]struct {
		result1 *v1alpha1.CreateMicroVMResponse
		result2 error
	}
	DeleteMicroVMStub        func(context.Context, *v1alpha1.DeleteMicroVMRequest, ...grpc.CallOption) (*emptypb.Empty, error)
	deleteMicroVMMutex       sync.RWMutex
	deleteMicroVMArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.DeleteMicroVMRequest
		arg3 []grpc.CallOption
	}
	deleteMicroVMReturns struct {
		result1 *emptypb.Empty
		result2 error
	}
	deleteMicroVMReturnsOnCall map[int]struct {
		result1 *emptypb.Empty
		result2 error
	}
	GetMicroVMStub        func(context.Context, *v1alpha1.GetMicroVMRequest, ...grpc.CallOption) (*v1alpha1.GetMicroVMResponse, error)
	getMicroVMMutex       sync.RWMutex
	getMicroVMArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.GetMicroVMRequest
		arg3 []grpc.CallOption
	}
	getMicroVMReturns struct {
		result1 *v1alpha1.GetMicroVMResponse
		result2 error
	}
	getMicroVMReturnsOnCall map[int]struct {
		result1 *v1alpha1.GetMicroVMResponse
		result2 error
	}
	ListMicroVMsStub        func(context.Context, *v1alpha1.ListMicroVMsRequest, ...grpc.CallOption) (*v1alpha1.ListMicroVMsResponse, error)
	listMicroVMsMutex       sync.RWMutex
	listMicroVMsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.ListMicroVMsRequest
		arg3 []grpc.CallOption
	}
	listMicroVMsReturns struct {
		result1 *v1alpha1.ListMicroVMsResponse
		result2 error
	}
	listMicroVMsReturnsOnCall map[int]struct {
		result1 *v1alpha1.ListMicroVMsResponse
		result2 error
	}
	ListMicroVMsStreamStub        func(context.Context, *v1alpha1.ListMicroVMsRequest, ...grpc.CallOption) (v1alpha1.MicroVM_ListMicroVMsStreamClient, error)
	listMicroVMsStreamMutex       sync.RWMutex
	listMicroVMsStreamArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.ListMicroVMsRequest
		arg3 []grpc.CallOption
	}
	listMicroVMsStreamReturns struct {
		result1 v1alpha1.MicroVM_ListMicroVMsStreamClient
		result2 error
	}
	listMicroVMsStreamReturnsOnCall map[int]struct {
		result1 v1alpha1.MicroVM_ListMicroVMsStreamClient
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeClient) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeClient) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeClient) CreateMicroVM(arg1 context.Context, arg2 *v1alpha1.CreateMicroVMRequest, arg3 ...grpc.CallOption) (*v1alpha1.CreateMicroVMResponse, error) {
	fake.createMicroVMMutex.Lock()
	ret, specificReturn := fake.createMicroVMReturnsOnCall[len(fake.createMicroVMArgsForCall)]
	fake.createMicroVMArgsForCall = append(fake.createMicroVMArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.CreateMicroVMRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CreateMicroVMStub
	fakeReturns := fake.createMicroVMReturns
	fake.recordInvocation("CreateMicroVM", []interface{}{arg1, arg2, arg3})
	fake.createMicroVMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateMicroVMCallCount() int {
	fake.createMicroVMMutex.RLock()
	defer fake.createMicroVMMutex.RUnlock()
	return len(fake.createMicroVMArgsForCall)
}

func (fake *FakeClient) CreateMicroVMCalls(stub func(context.Context, *v1alpha1.CreateMicroVMRequest, ...grpc.CallOption) (*v1alpha1.CreateMicroVMResponse, error)) {
	fake.createMicroVMMutex.Lock()
	defer fake.createMicroVMMutex.Unlock()
	fake.CreateMicroVMStub = stub
}

func (fake *FakeClient) CreateMicroVMArgsForCall(i int) (context.Context, *v1alpha1.CreateMicroVMRequest, []grpc.CallOption) {
	fake.createMicroVMMutex.RLock()
	defer fake.createMicroVMMutex.RUnlock()
	argsForCall := fake.createMicroVMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CreateMicroVMReturns(result1 *v1alpha1.CreateMicroVMResponse, result2 error) {
	fake.createMicroVMMutex.Lock()
	defer fake.createMicroVMMutex.Unlock()
	fake.CreateMicroVMStub = nil
	fake.createMicroVMReturns = struct {
		result1 *v1alpha1.CreateMicroVMResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateMicroVMReturnsOnCall(i int, result1 *v1alpha1.CreateMicroVMResponse, result2 error) {
	fake.createMicroVMMutex.Lock()
	defer fake.createMicroVMMutex.Unlock()
	fake.CreateMicroVMStub = nil
	if fake.createMicroVMReturnsOnCall == nil {
		fake.createMicroVMReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.CreateMicroVMResponse
			result2 error
		})
	}
	fake.createMicroVMReturnsOnCall[i] = struct {
		result1 *v1alpha1.CreateMicroVMResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteMicroVM(arg1 context.Context, arg2 *v1alpha1.DeleteMicroVMRequest, arg3 ...grpc.CallOption) (*emptypb.Empty, error) {
	fake.deleteMicroVMMutex.Lock()
	ret, specificReturn := fake.deleteMicroVMReturnsOnCall[len(fake.deleteMicroVMArgsForCall)]
	fake.deleteMicroVMArgsForCall = append(fake.deleteMicroVMArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.DeleteMicroVMRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteMicroVMStub
	fakeReturns := fake.deleteMicroVMReturns
	fake.recordInvocation("DeleteMicroVM", []interface{}{arg1, arg2, arg3})
	fake.deleteMicroVMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeleteMicroVMCallCount() int {
	fake.deleteMicroVMMutex.RLock()
	defer fake.deleteMicroVMMutex.RUnlock()
	return len(fake.deleteMicroVMArgsForCall)
}

func (fake *FakeClient) DeleteMicroVMCalls(stub func(context.Context, *v1alpha1.DeleteMicroVMRequest, ...grpc.CallOption) (*emptypb.Empty, error)) {
	fake.deleteMicroVMMutex.Lock()
	defer fake.deleteMicroVMMutex.Unlock()
	fake.DeleteMicroVMStub = stub
}

func (fake *FakeClient) DeleteMicroVMArgsForCall(i int) (context.Context, *v1alpha1.DeleteMicroVMRequest, []grpc.CallOption) {
	fake.deleteMicroVMMutex.RLock()
	defer fake.deleteMicroVMMutex.RUnlock()
	argsForCall := fake.deleteMicroVMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) DeleteMicroVMReturns(result1 *emptypb.Empty, result2 error) {
	fake.deleteMicroVMMutex.Lock()
	defer fake.deleteMicroVMMutex.Unlock()
	fake.DeleteMicroVMStub = nil
	fake.deleteMicroVMReturns = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteMicroVMReturnsOnCall(i int, result1 *emptypb.Empty, result2 error) {
	fake.deleteMicroVMMutex.Lock()
	defer fake.deleteMicroVMMutex.Unlock()
	fake.DeleteMicroVMStub = nil
	if fake.deleteMicroVMReturnsOnCall == nil {
		fake.deleteMicroVMReturnsOnCall = make(map[int]struct {
			result1 *emptypb.Empty
			result2 error
		})
	}
	fake.deleteMicroVMReturnsOnCall[i] = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetMicroVM(arg1 context.Context, arg2 *v1alpha1.GetMicroVMRequest, arg3 ...grpc.CallOption) (*v1alpha1.GetMicroVMResponse, error) {
	fake.getMicroVMMutex.Lock()
	ret, specificReturn := fake.getMicroVMReturnsOnCall[len(fake.getMicroVMArgsForCall)]
	fake.getMicroVMArgsForCall = append(fake.getMicroVMArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.GetMicroVMRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetMicroVMStub
	fakeReturns := fake.getMicroVMReturns
	fake.recordInvocation("GetMicroVM", []interface{}{arg1, arg2, arg3})
	fake.getMicroVMMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetMicroVMCallCount() int {
	fake.getMicroVMMutex.RLock()
	defer fake.getMicroVMMutex.RUnlock()
	return len(fake.getMicroVMArgsForCall)
}

func (fake *FakeClient) GetMicroVMCalls(stub func(context.Context, *v1alpha1.GetMicroVMRequest, ...grpc.CallOption) (*v1alpha1.GetMicroVMResponse, error)) {
	fake.getMicroVMMutex.Lock()
	defer fake.getMicroVMMutex.Unlock()
	fake.GetMicroVMStub = stub
}

func (fake *FakeClient) GetMicroVMArgsForCall(i int) (context.Context, *v1alpha1.GetMicroVMRequest, []grpc.CallOption) {
	fake.getMicroVMMutex.RLock()
	defer fake.getMicroVMMutex.RUnlock()
	argsForCall := fake.getMicroVMArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetMicroVMReturns(result1 *v1alpha1.GetMicroVMResponse, result2 error) {
	fake.getMicroVMMutex.Lock()
	defer fake.getMicroVMMutex.Unlock()
	fake.GetMicroVMStub = nil
	fake.getMicroVMReturns = struct {
		result1 *v1alpha1.GetMicroVMResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetMicroVMReturnsOnCall(i int, result1 *v1alpha1.GetMicroVMResponse, result2 error) {
	fake.getMicroVMMutex.Lock()
	defer fake.getMicroVMMutex.Unlock()
	fake.GetMicroVMStub = nil
	if fake.getMicroVMReturnsOnCall == nil {
		fake.getMicroVMReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.GetMicroVMResponse
			result2 error
		})
	}
	fake.getMicroVMReturnsOnCall[i] = struct {
		result1 *v1alpha1.GetMicroVMResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListMicroVMs(arg1 context.Context, arg2 *v1alpha1.ListMicroVMsRequest, arg3 ...grpc.CallOption) (*v1alpha1.ListMicroVMsResponse, error) {
	fake.listMicroVMsMutex.Lock()
	ret, specificReturn := fake.listMicroVMsReturnsOnCall[len(fake.listMicroVMsArgsForCall)]
	fake.listMicroVMsArgsForCall = append(fake.listMicroVMsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.ListMicroVMsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListMicroVMsStub
	fakeReturns := fake.listMicroVMsReturns
	fake.recordInvocation("ListMicroVMs", []interface{}{arg1, arg2, arg3})
	fake.listMicroVMsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListMicroVMsCallCount() int {
	fake.listMicroVMsMutex.RLock()
	defer fake.listMicroVMsMutex.RUnlock()
	return len(fake.listMicroVMsArgsForCall)
}

func (fake *FakeClient) ListMicroVMsCalls(stub func(context.Context, *v1alpha1.ListMicroVMsRequest, ...grpc.CallOption) (*v1alpha1.ListMicroVMsResponse, error)) {
	fake.listMicroVMsMutex.Lock()
	defer fake.listMicroVMsMutex.Unlock()
	fake.ListMicroVMsStub = stub
}

func (fake *FakeClient) ListMicroVMsArgsForCall(i int) (context.Context, *v1alpha1.ListMicroVMsRequest, []grpc.CallOption) {
	fake.listMicroVMsMutex.RLock()
	defer fake.listMicroVMsMutex.RUnlock()
	argsForCall := fake.listMicroVMsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ListMicroVMsReturns(result1 *v1alpha1.ListMicroVMsResponse, result2 error) {
	fake.listMicroVMsMutex.Lock()
	defer fake.listMicroVMsMutex.Unlock()
	fake.ListMicroVMsStub = nil
	fake.listMicroVMsReturns = struct {
		result1 *v1alpha1.ListMicroVMsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListMicroVMsReturnsOnCall(i int, result1 *v1alpha1.ListMicroVMsResponse, result2 error) {
	fake.listMicroVMsMutex.Lock()
	defer fake.listMicroVMsMutex.Unlock()
	fake.ListMicroVMsStub = nil
	if fake.listMicroVMsReturnsOnCall == nil {
		fake.listMicroVMsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ListMicroVMsResponse
			result2 error
		})
	}
	fake.listMicroVMsReturnsOnCall[i] = struct {
		result1 *v1alpha1.ListMicroVMsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListMicroVMsStream(arg1 context.Context, arg2 *v1alpha1.ListMicroVMsRequest, arg3 ...grpc.CallOption) (v1alpha1.MicroVM_ListMicroVMsStreamClient, error) {
	fake.listMicroVMsStreamMutex.Lock()
	ret, specificReturn := fake.listMicroVMsStreamReturnsOnCall[len(fake.listMicroVMsStreamArgsForCall)]
	fake.listMicroVMsStreamArgsForCall = append(fake.listMicroVMsStreamArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.ListMicroVMsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListMicroVMsStreamStub
	fakeReturns := fake.listMicroVMsStreamReturns
	fake.recordInvocation("ListMicroVMsStream", []interface{}{arg1, arg2, arg3})
	fake.listMicroVMsStreamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListMicroVMsStreamCallCount() int {
	fake.listMicroVMsStreamMutex.RLock()
	defer fake.listMicroVMsStreamMutex.RUnlock()
	return len(fake.listMicroVMsStreamArgsForCall)
}

func (fake *FakeClient) ListMicroVMsStreamCalls(stub func(context.Context, *v1alpha1.ListMicroVMsRequest, ...grpc.CallOption) (v1alpha1.MicroVM_ListMicroVMsStreamClient, error)) {
	fake.listMicroVMsStreamMutex.Lock()
	defer fake.listMicroVMsStreamMutex.Unlock()
	fake.ListMicroVMsStreamStub = stub
}

func (fake *FakeClient) ListMicroVMsStreamArgsForCall(i int) (context.Context, *v1alpha1.ListMicroVMsRequest, []grpc.CallOption) {
	fake.listMicroVMsStreamMutex.RLock()
	defer fake.listMicroVMsStreamMutex.RUnlock()
	argsForCall := fake.listMicroVMsStreamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ListMicroVMsStreamReturns(result1 v1alpha1.MicroVM_ListMicroVMsStreamClient, result2 error) {
	fake.listMicroVMsStreamMutex.Lock()
	defer fake.listMicroVMsStreamMutex.Unlock()
	fake.ListMicroVMsStreamStub = nil
	fake.listMicroVMsStreamReturns = struct {
		result1 v1alpha1.MicroVM_ListMicroVMsStreamClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListMicroVMsStreamReturnsOnCall(i int, result1 v1alpha1.MicroVM_ListMicroVMsStreamClient, result2 error) {
	fake.listMicroVMsStreamMutex.Lock()
	defer fake.listMicroVMsStreamMutex.Unlock()
	fake.ListMicroVMsStreamStub = nil
	if fake.listMicroVMsStreamReturnsOnCall == nil {
		fake.listMicroVMsStreamReturnsOnCall = make(map[int]struct {
			result1 v1alpha1.MicroVM_ListMicroVMsStreamClient
			result2 error
		})
	}
	fake.listMicroVMsStreamReturnsOnCall[i] = struct {
		result1 v1alpha1.MicroVM_ListMicroVMsStreamClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createMicroVMMutex.RLock()
	defer fake.createMicroVMMutex.RUnlock()
	fake.deleteMicroVMMutex.RLock()
	defer fake.deleteMicroVMMutex.RUnlock()
	fake.getMicroVMMutex.RLock()
	defer fake.getMicroVMMutex.RUnlock()
	fake.listMicroVMsMutex.RLock()
	defer fake.listMicroVMsMutex.RUnlock()
	fake.listMicroVMsStreamMutex.RLock()
	defer fake.listMicroVMsStreamMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
